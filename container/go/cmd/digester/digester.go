// Copyright 2017 The Bazel Authors. All rights reserved.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at

//    http://www.apache.org/licenses/LICENSE-2.0

// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License/
////////////////////////////////////
//This binary implements the ability to load a docker image, calculate its image manifest sha256 hash and output a digest file.
package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/rules_docker/container/go/pkg/compat"
	"github.com/bazelbuild/rules_docker/container/go/pkg/utils"
	v1 "github.com/google/go-containerregistry/pkg/v1"
	"github.com/google/go-containerregistry/pkg/v1/types"
	"github.com/pkg/errors"
)

var (
	dst     = flag.String("dst", "", "The destination location of the digest file to write to.")
	src     = flag.String("src", "", "Path to the config.json when -format is legacy, path to the index.json when -format is oci or path to the image .tar file when -format is docker.")
	format  = flag.String("format", "", "The format of the source image, (oci, legacy, or docker). The docker format should be a tarball of the image as generated by docker save.")
	tarball = flag.String("tarball", "", "The path to a legacy base image in tarball form, optional.")
	layers  utils.ArrayStringFlags
)

const (
	// manifestFile is the filename of image manifest.
	manifestFile = "manifest.json"
	// configFile is the filename of image config.
	configFile = "config.json"
	// indexManifestFile is the filename of image manifest config in OCI format.
	indexManifestFile = "index.json"
)

func main() {
	flag.Var(&layers, "layers", "The list of paths to the layers of this docker image, only used for legacy images.")
	flag.Parse()
	log.Println("Running the Image Digester to generate an image digest file...")

	if *dst == "" {
		log.Fatalln("Required option -dst was not specified.")
	}
	if *src == "" {
		log.Fatalln("Required option -src was not specified.")
	}
	if *format == "" {
		log.Fatalln("Required option -format was not specified.")
	}

	// Validates provided format and src path. Check if src is a tarball when pushing a docker image. Trim basename index.json or manifest.json if src is a directory, since we are pushing a OCI/legacy index.
	var imgSrc string
	if *format == "docker" && filepath.Ext(*src) != ".tar" {
		log.Fatalf("Invalid value for argument -src for -format=docker, got %q, want path to tarball file with extension .tar.", *src)
	}
	if *format == "legacy" && filepath.Base(*src) != configFile {
		log.Fatalf("Invalid value for argument -src for -format=legacy, got %q, want path to %s", *src, configFile)
	}
	if *format == "oci" && filepath.Base(*src) != indexManifestFile {
		log.Fatalf("Invalid value for argument -src for -format=oci, got %q, want path to %s", *src, indexManifestFile)
	}
	if *format == "oci" || *format == "legacy" {
		imgSrc = filepath.Dir(*src)
		log.Printf("Determined image source path to be %s based on -format=%s, -src=%s.", imgSrc, *format, *src)
	}
	if *format == "docker" {
		imgSrc = *src
	}
	if *format == "legacy" && *tarball == "" {
		manifestPath := filepath.Join(imgSrc, manifestFile)

		// TODO (xiaohegong): remove generate manifest after createImageConfig is merged.
		log.Printf("Generating image manifest to %s...", manifestPath)
		_, err := compat.GenerateManifest(imgSrc, manifestPath, filepath.Join(imgSrc, configFile), layers)
		if err != nil {
			log.Fatalf("Error generating %s from %s: %v", manifestFile, imgSrc, err)
		}
	}

	img, err := utils.ReadImage(imgSrc, *format, *tarball, layers)
	if err != nil {
		log.Fatalf("Error reading from %s: %v", imgSrc, err)
	}

	configPath := ""
	if *format == "legacy"{
		configPath = *src
	}
	err = writeDigest(img, *dst, configPath)
	if err != nil {
		log.Fatalf("Error outputting digest file to %s: %v", *dst, err)
	}

	log.Printf("Successfully generated image digest file at %s", *dst)
}

// writeDigest outputs image's digest to a "digest file" at dst. Digest is the image manifest's sha256 hash.
func writeDigest(image v1.Image, dst, configPath string) error {
	m, err := image.Manifest()
	if err != nil {
		return errors.Wrap(err, "error getting image manifest")
	}

	var rawConfig []byte
	if configPath == "" {
		rawConfig, err = image.RawConfigFile()
		if err != nil {
			return errors.Wrap(err, "Error getting image raw config")
		}
		
		cfgHash, cfgSize, err := v1.SHA256(bytes.NewReader(rawConfig))
		if err != nil {
			return errors.Wrap(err, "unable to hash image config file")
		}

		m.Config = v1.Descriptor{
			MediaType: types.DockerConfigJSON,
			Size:      cfgSize,
			Digest:    cfgHash,
		}
	}

	out, err := formatStruct(m)
	if err != nil {
		return err
	}

	digest, _, err := v1.SHA256(bytes.NewReader((*out).Bytes()))
	if err != nil {
		return errors.Wrap(err, "unable to compute sha256 sum for digest")
	}

	rawDigest := []byte(digest.Algorithm + ":" + digest.Hex)

	err = ioutil.WriteFile(dst, rawDigest, os.ModePerm)
	if err != nil {
		return errors.Wrapf(err, "unable to write digest file to %s", dst)
	}

	return nil
}

func formatStruct(s interface{}) (*bytes.Buffer, error) {

	raw, err := json.Marshal(s)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get the JSON encoding of manifest")
	}

	// Converting Manifest to string map sorts the output json by key
	var o map[string]interface{}
	if err := json.Unmarshal(raw, &o); err != nil {
		return nil, errors.Wrap(err, "unable to get the JSON encoding of manifest")
	}

	raw, err = json.Marshal(o)
	if err != nil {
		return nil, errors.Wrap(err, "unable to get the JSON encoding of manifest")
	}

	// Manually remove new line char and add space after comma for consistency with digester.py
	var out bytes.Buffer
	json.Indent(&out, raw, "", "")
	outStr := strings.ReplaceAll(out.String(), ",\n", ", ")
	outStr = strings.ReplaceAll(outStr, "\n", "")

	return bytes.NewBufferString(outStr), nil

}
