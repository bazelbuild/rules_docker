// Copyright 2015 The Bazel Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//////////////////////////////////////////////////////////////////////
// This binary pushes an image to a Docker Registry.
package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/bazelbuild/rules_docker/container/go/pkg/compat"
	"github.com/bazelbuild/rules_docker/container/go/pkg/oci"
	"github.com/google/go-containerregistry/pkg/authn"
	"github.com/google/go-containerregistry/pkg/name"
	v1 "github.com/google/go-containerregistry/pkg/v1"
	"github.com/google/go-containerregistry/pkg/v1/remote"
	"github.com/google/go-containerregistry/pkg/v1/tarball"
	"github.com/google/go-containerregistry/pkg/v1/types"
	"github.com/pkg/errors"
)

var (
	dst             = flag.String("dst", "", "The destination location including repo and digest/tag of the docker image to push. Supports fully-qualified tag or digest references.")
	src             = flag.String("src", "", "Path to the manifest.json when -format is legacy, path to the index.json when -format is oci or path to the image .tar file when -format is docker.")
	format          = flag.String("format", "", "The format of the source image, (oci, legacy, or docker). The docker format should be a tarball of the image as generated by docker save.")
	clientConfigDir = flag.String("client-config-dir", "", "The path to the directory where the client configuration files are located. Overiddes the value from DOCKER_CONFIG.")
)

const (
	schemaVersion = 2
)

func main() {
	flag.Parse()
	log.Println("Running the Image Pusher to push images to a Docker Registry...")

	if *dst == "" {
		log.Fatalln("Required option -dst was not specified.")
	}
	if *src == "" {
		log.Fatalln("Required option -src was not specified.")
	}
	if *format == "" {
		log.Fatalln("Required option -format was not specified.")
	}

	// If the user provided a client config directory, instruct the keychain resolver
	// to use it to look for the docker client config.
	if *clientConfigDir != "" {
		os.Setenv("DOCKER_CONFIG", *clientConfigDir)
	}

	// Validates provided format and src path. Check if src is a tarball when pushing a docker image. Trim basename index.json or manifest.json if src is a directory, since we are pushing a OCI/legacy index.
	var imgSrc string
	if *format == "docker" && filepath.Ext(*src) != ".tar" {
		log.Fatalf("Invalid value for argument -src for -format=docker, got %q, want path to tarball file with extension .tar.", *src)
	}
	// if *format == "legacy" && filepath.Base(*src) != "config.json" {
	// 	log.Fatalf("Invalid value for argument -src for -format=legacy, got %q, want path to manifest.json", *src)
	// }
	if *format == "oci" && filepath.Base(*src) != "index.json" {
		log.Fatalf("Invalid value for argument -src for -format=oci, got %q, want path to index.json", *src)
	}
	if *format == "oci" || *format == "legacy" {
		imgSrc = filepath.Dir(*src)
		log.Printf("Determined image source path to be %q based on -format=%q, -src=%q.", imgSrc, *format, *src)
	}
	if *format == "docker" {
		imgSrc = *src
	}

	// wd, _ := os.Getwd()
	// log.Printf("Working directory: %s", wd)

	imageRunfiles, err := ioutil.ReadDir(imgSrc)
	if err != nil {
		log.Fatalf("Error reading legacy image files from %s: %v", imgSrc, err)
	}
	log.Print(imageRunfiles)

	var configDir string
	var layersDir []string
	for _, f := range imageRunfiles {
		log.Print(f.Name())
		if strings.Contains(f.Name(), "config") {
			configDir = filepath.Join(imgSrc, f.Name())
		} else if strings.Contains(f.Name(), ".tar.gz") {
			layersDir = append(layersDir, filepath.Join(imgSrc, f.Name()))
		}
	}

	log.Print(configDir)
	log.Print(layersDir)

	m, err := buildManifest(configDir, layersDir)
	if err != nil {
		log.Fatalf("unable to construct manifest: %v", err)
	}

	//TODO: write a manifest.json to dst directory
	writeManifest(m, imgSrc)

	img, err := readImage(imgSrc, *format)
	if err != nil {
		log.Fatalf("error reading from %s: %v", imgSrc, err)
	}

	if err := push(*dst, img); err != nil {
		log.Fatalf("error pushing image to %s: %v", *dst, err)
	}

	log.Printf("Successfully pushed %s image from %s to %s", *format, imgSrc, *dst)
}

// push pushes the given image to the given destination.
// NOTE: This function is adapted from https://github.com/google/go-containerregistry/blob/master/pkg/crane/push.go
// with modification for option to push OCI layout, legacy layout or Docker tarball format.
// Push the given image to destination <dst>.
func push(dst string, img v1.Image) error {
	// Push the image to dst.
	ref, err := name.ParseReference(dst)
	if err != nil {
		return errors.Wrapf(err, "error parsing %q as an image reference", dst)
	}

	if err := remote.Write(ref, img, remote.WithAuthFromKeychain(authn.DefaultKeychain)); err != nil {
		return errors.Wrapf(err, "unable to push image to %s", dst)
	}

	return nil
}

// readImage returns a v1.Image after reading an legacy layout, an OCI layout or a Docker tarball from src.
func readImage(src, format string) (v1.Image, error) {
	if format == "oci" {
		return oci.Read(src)
	}
	if format == "legacy" {
		return compat.Read(src)
	}
	if format == "docker" {
		return tarball.ImageFromPath(src, nil)
	}

	return nil, errors.Errorf("unknown image format %q", format)
}

func buildManifest(configDir string, layersDir []string) (v1.Manifest, error) {
	rawConfig, err := ioutil.ReadFile(configDir)
	if err != nil {
		return v1.Manifest{}, err
	}
	cfgHash, cfgSize, err := v1.SHA256(bytes.NewReader(rawConfig))
	if err != nil {
		return v1.Manifest{}, err
	}

	manifest := v1.Manifest{
		SchemaVersion: schemaVersion,
		MediaType:     types.DockerManifestSchema2,
		Config: v1.Descriptor{
			MediaType: types.DockerConfigJSON,
			Size:      cfgSize,
			Digest:    cfgHash,
		},
	}

	// TODO: errors
	manifest.Layers = make([]v1.Descriptor, len(layersDir))
	for i, l := range layersDir {
		layer, err := tarball.LayerFromFile(l)
		if err != nil {
			return v1.Manifest{}, err
		}

		layerSize, err := layer.Size()
		if err != nil {
			return v1.Manifest{}, err
		}
		layerHash, err := layer.Digest()
		if err != nil {
			return v1.Manifest{}, err
		}

		manifest.Layers[i] = v1.Descriptor{
			MediaType: types.DockerLayer,
			Size:      layerSize,
			Digest:    layerHash,
		}
	}

	return manifest, nil
}

func writeManifest(m v1.Manifest, path string) error {
	dst := path + "/manifest.json"
	// digestPath := path + "/digest"
	// log.Fatalf("%s", dst)
	rawManifest, err := json.Marshal(m)
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(dst, rawManifest, os.ModePerm)
	if err != nil {
		return err
	}
	// outputDigest(rawManifest, digestPath)

	return nil
}

// func outputDigest(rawManifest []byte, dst string) error {
// 	h, _, err := v1.SHA256(bytes.NewReader(rawManifest))
// 	if err != nil {
// 		return err
// 	}

// 	log.Printf("dst:%s", dst)
// 	rawDigest, err := json.Marshal(h.Hex())
// 	if err != nil {
// 		return err
// 	}

// 	err = ioutil.WriteFile(dst, rawDigest, os.ModePerm)
// 	if err != nil {
// 		return err
// 	}
// 	return nil
// }
