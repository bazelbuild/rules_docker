package utils

import (
	"errors"
	"flag"
)

// ImageIndexArgs contains all informations related to a single image of an image index.
// See `cmd/digester_index` and `cmd/pusher_index` for more details.
type ImageIndexArgs struct {
	Platform struct {
		OS      string
		Arch    string
		Variant string
	}
	Config   string
	Layers   []string
	Tarball  string
	Manifest string
}

// Parse parses the given application arguments.
// Returns the list of extra args.
func (ia *ImageIndexArgs) Parse(appName string, argv []string) ([]string, error) {
	fl := flag.NewFlagSet(appName, flag.ContinueOnError)
	fl.StringVar(
		&ia.Platform.OS, "os", "",
		"OS of the Docker image.",
	)
	fl.StringVar(
		&ia.Platform.Arch, "arch", "",
		"Architecture of the Docker image.",
	)
	fl.StringVar(
		&ia.Platform.Variant, "variant", "",
		"Architecture variant of the Docker image.",
	)

	fl.StringVar(
		&ia.Config, "config", "",
		"Path to the image config.json. Required if --tarball was not specified.",
	)
	fl.Var(
		(*ArrayStringFlags)(&ia.Layers), "layer",
		"One or more layers with the following comma separated values (Compressed layer tarball, Uncompressed layer tarball, digest file, diff ID file)."+
			"e.g., --layer layer.tar.gz,layer.tar,<file with digest>,<file with diffID>.",
	)
	fl.StringVar(
		&ia.Tarball, "tarball", "",
		"Path to the image tarball as generated by docker save. Required if --config was not specified.",
	)
	fl.StringVar(
		&ia.Manifest, "manifest", "",
		"Path to the manifest of the base image. This should be the very first image in the chain of images and is only really required for windows images with a base image that has foreign layers.",
	)

	if err := fl.Parse(argv); err != nil {
		return nil, err
	}

	if ia.Tarball == "" && ia.Config == "" {
		return nil, errors.New("neither --tarball nor --config was specified")
	}

	return fl.Args(), nil
}
